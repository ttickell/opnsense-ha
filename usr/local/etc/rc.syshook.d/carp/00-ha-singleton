#!/bin/sh

# OPNsense HA Singleton CARP Hook Script
# Manages interface states, services, and routing based on CARP status
# Version: 2.4 - Enhanced interface and route management with configctl fallback
#
# Implementation Notes:
# - Uses configctl interface linkup.start/stop with verification and ifconfig fallback
# - Enhanced route management: removes existing default routes before adding backup routes
# - Fixes "route already in table" errors by properly managing route table
# - Enhanced IPv6 service restart during CARP state transitions
# - Compatible with interface_suspend() patterns used in OPNsense 20-ppp hook

TAG="syshook-carp-ha-singleton"
LOCKFILE="/var/run/${TAG}.lock"
CONFIG_FILE="/usr/local/etc/ha-singleton.conf"

# Script arguments
INTERFACE=$1
CARP_STATUS=$2

# Default configuration (overridden by config file if it exists)
WAN_INTS="__INT_LIST__"
SERVICES="rtsold dhcp6c radvd"
ALT_DEFROUTE_IPV4="192.168.105.2"
ALT_DEFROUTE_IPV6="fd03:17ac:e938:10::2"
ENABLE_IPV6="yes"
ENABLE_SERVICE_MANAGEMENT="yes"
ENABLE_ROUTE_MANAGEMENT="yes"
DEBUG="no"

# Load configuration file if it exists
if [ -f "${CONFIG_FILE}" ]; then
    . "${CONFIG_FILE}"
fi



# Lock management functions
acquire_lock() {
    if [ -f "${LOCKFILE}" ]; then
        local pid=$(cat "${LOCKFILE}")
        if ps -p "${pid}" > /dev/null 2>&1; then
            logger -p warning -t ${TAG} "Script already running (PID: ${pid}), exiting"
            exit 0
        else
            logger -p info -t ${TAG} "Removing stale lock file"
            rm -f "${LOCKFILE}"
        fi
    fi
    echo $$ > "${LOCKFILE}"
}

release_lock() {
    rm -f "${LOCKFILE}"
}

# Set up exit trap
trap release_lock EXIT

# Validation and initialization
validate_environment() {
    if [ -z "${INTERFACE}" ] || [ -z "${CARP_STATUS}" ]; then
        logger -p error -t ${TAG} "Missing required environment variables: INTERFACE=${INTERFACE} CARP_STATUS=${CARP_STATUS}"
        exit 1
    fi
    
    # Normalize CARP status
    case "${CARP_STATUS}" in
        "MASTER")
            ;;
        "BACKUP")
            ;;
        "INIT")
            logger -p info -t ${TAG} "CARP in INIT state, treating as BACKUP"
            CARP_STATUS="BACKUP"
            ;;
        *)
            logger -p warning -t ${TAG} "Unknown CARP status: ${CARP_STATUS}, treating as BACKUP"
            CARP_STATUS="BACKUP"
            ;;
    esac
}

# Debug logging function
debug_log() {
    if [ "${DEBUG}" = "yes" ]; then
        logger -p info -t ${TAG} "[DEBUG] $1"
    fi
}

# System tunable initialization
init_system_tunables() {
    # Disable PFSYNC CARP demotion to prevent flapping during primary failures
    local current_factor=$(sysctl -n net.pfsync.carp_demotion_factor 2>/dev/null || echo "240")
    if [ "${current_factor}" != "0" ]; then
        logger -p info -t ${TAG} "Setting PFSYNC CARP demotion factor to 0 (was ${current_factor})"
        sysctl net.pfsync.carp_demotion_factor=0 >/dev/null 2>&1 || \
            logger -p warning -t ${TAG} "Failed to set PFSYNC demotion factor"
    fi
}

# Initialize
acquire_lock
validate_environment
init_system_tunables

logger -p info -t ${TAG} "Processing CARP event: ${INTERFACE} -> ${CARP_STATUS}"
debug_log "Configuration: WAN_INTS=${WAN_INTS}, IPv6=${ENABLE_IPV6}, Services=${ENABLE_SERVICE_MANAGEMENT}"

# Interface management functions
get_interface_status() {
    local interface=$1
    if ifconfig -l -u | grep -q "${interface}"; then
        echo "UP"
    else
        echo "DOWN"
    fi
}

manage_wan_interfaces() {
    logger -p info -t ${TAG} "Managing WAN interfaces for CARP status: ${CARP_STATUS}"
    
    for WAN_INT in ${WAN_INTS}; do
        # Validate interface exists
        if ! ifconfig "${WAN_INT}" >/dev/null 2>&1; then
            logger -p warning -t ${TAG} "Interface ${WAN_INT} does not exist, skipping"
            continue
        fi
        
        local cur_status=$(get_interface_status "${WAN_INT}")
        debug_log "Interface ${WAN_INT} current status: ${cur_status}"
        
        case "${CARP_STATUS}" in
            "MASTER")
                if [ "${cur_status}" = "DOWN" ]; then
                    logger -p info -t ${TAG} "Bringing up ${WAN_INT} (CARP MASTER)"
                    if ! configctl interface linkup.start "${WAN_INT}" 2>/dev/null; then
                        logger -p warning -t ${TAG} "configctl linkup.start failed, using ifconfig for ${WAN_INT}"
                        ifconfig "${WAN_INT}" up
                    fi
                else
                    debug_log "${WAN_INT} already UP, no action needed"
                fi
                ;;
            "BACKUP")
                if [ "${cur_status}" = "UP" ]; then
                    logger -p info -t ${TAG} "Bringing down ${WAN_INT} (CARP BACKUP)"
                    # Try configctl first, then fall back to ifconfig 
                    if ! configctl interface linkup.stop "${WAN_INT}" >/dev/null 2>&1; then
                        logger -p info -t ${TAG} "configctl not available, using ifconfig for ${WAN_INT}"
                        ifconfig "${WAN_INT}" down
                    else
                        # Verify the interface went down
                        sleep 1
                        if [ "$(get_interface_status "${WAN_INT}")" = "UP" ]; then
                            logger -p warning -t ${TAG} "configctl failed to bring down ${WAN_INT}, using ifconfig"
                            ifconfig "${WAN_INT}" down
                        fi
                    fi
                else
                    debug_log "${WAN_INT} already DOWN, no action needed"
                fi
                ;;
        esac
    done
}

# Service management functions
check_service_status() {
    local service=$1
    service "${service}" status >/dev/null 2>&1
    return $?
}

start_service() {
    local service=$1
    logger -p info -t ${TAG} "Starting service: ${service}"
    
    # Skip configctl for IPv6 services that don't have configctl actions
    case "${service}" in
        rtsold|dhcp6c|radvd)
            # Use direct daemon commands for IPv6 services
            case "${service}" in
                rtsold)
                    # Use conditional rtsold scripts based on CARP state
                    if [ "${CARP_STATUS}" = "MASTER" ]; then
                        # Full rtsold with scripts for proper IPv6 operation
                        /usr/sbin/rtsold -aiu -p /var/run/rtsold.pid -A /var/etc/rtsold_script.sh -R /usr/local/opnsense/scripts/interfaces/rtsold_resolvconf.sh
                    else
                        # Minimal rtsold for BACKUP state to avoid interface conflicts
                        /usr/sbin/rtsold -aiu -p /var/run/rtsold.pid
                    fi
                    ;;
                radvd)
                    /usr/local/sbin/radvd -p /var/run/radvd.pid -C /var/etc/radvd.conf -m syslog
                    ;;
                dhcp6c)
                    # Enhanced dhcp6c startup with interface validation
                    local dhcp6c_config="/var/etc/dhcp6c.conf"
                    if [ -f "${dhcp6c_config}" ]; then
                        # Kill any existing dhcp6c processes that might be stuck
                        pkill -f dhcp6c 2>/dev/null || true
                        sleep 1
                        # Start dhcp6c with fresh configuration
                        /usr/local/sbin/dhcp6c -c "${dhcp6c_config}" -p /var/run/dhcp6c.pid
                        debug_log "Started dhcp6c with config: ${dhcp6c_config}"
                    else
                        logger -p warning -t ${TAG} "dhcp6c config file not found: ${dhcp6c_config}"
                    fi
                    ;;
            esac
            ;;
        *)
            # Try configctl for other services
            if ! configctl "${service}" start 2>/dev/null; then
                logger -p warning -t ${TAG} "Unknown service for configctl: ${service}"
                return 1
            fi
            ;;
    esac
}

stop_service() {
    local service=$1
    logger -p info -t ${TAG} "Stopping service: ${service}"
    
    # Skip configctl for IPv6 services that don't have configctl actions  
    case "${service}" in
        rtsold|dhcp6c|radvd)
            # Use FreeBSD service management for IPv6 services
            service "${service}" onestop
            ;;
        *)
            # Try configctl for other services
            if ! configctl "${service}" stop 2>/dev/null; then
                service "${service}" onestop
            fi
            ;;
    esac
}

restart_service() {
    local service=$1
    logger -p info -t ${TAG} "Restarting service: ${service}"
    
    # For IPv6 services, we need to restart them to rebind to correct interfaces
    case "${service}" in
        rtsold|dhcp6c|radvd)
            # Stop the service first
            service "${service}" onestop 2>/dev/null || true
            # Wait a moment for cleanup
            sleep 1
            # Start with fresh interface bindings
            start_service "${service}"
            ;;
        *)
            # Try configctl restart or fall back to service restart
            if ! configctl "${service}" restart 2>/dev/null; then
                service "${service}" onerestart 2>/dev/null || service "${service}" restart
            fi
            ;;
    esac
}

manage_services() {
    if [ "${ENABLE_SERVICE_MANAGEMENT}" != "yes" ]; then
        debug_log "Service management disabled, skipping"
        return
    fi
    
    logger -p info -t ${TAG} "Managing services for CARP status: ${CARP_STATUS}"
    
    for service in ${SERVICES}; do
        if check_service_status "${service}"; then
            local service_running=true
        else
            local service_running=false
        fi
        
        debug_log "Service ${service} running: ${service_running}"
        
        case "${CARP_STATUS}" in
            "MASTER")
                if [ "${service_running}" = "false" ]; then
                    start_service "${service}"
                else
                    # Critical fix: Restart IPv6 services when becoming MASTER
                    # This ensures they rebind to the correct interfaces
                    case "${service}" in
                        rtsold|dhcp6c|radvd)
                            logger -p info -t ${TAG} "Restarting ${service} for interface rebinding"
                            restart_service "${service}"
                            ;;
                        *)
                            debug_log "Service ${service} already running"
                            ;;
                    esac
                fi
                ;;
            "BACKUP")
                if [ "${service_running}" = "true" ]; then
                    stop_service "${service}"
                else
                    debug_log "Service ${service} already stopped"
                fi
                ;;
        esac
    done
}

# Route management functions
get_default_routes() {
    local family=$1
    case "${family}" in
        "ipv4")
            netstat -rn -f inet | awk '/^default/ {print $2}'
            ;;
        "ipv6")
            netstat -rn -f inet6 | awk '/^default/ {print $2}'
            ;;
        *)
            return 1
            ;;
    esac
}

check_route_exists() {
    local route_ip=$1
    local family=$2
    
    case "${family}" in
        "ipv4")
            netstat -rn -f inet | grep -q "default.*${route_ip}"
            ;;
        "ipv6")
            netstat -rn -f inet6 | grep -q "default.*${route_ip}"
            ;;
        *)
            return 1
            ;;
    esac
}

remove_default_routes() {
    local family=$1
    
    logger -p info -t ${TAG} "Removing existing ${family} default routes"
    
    case "${family}" in
        "ipv4")
            get_default_routes "ipv4" | while read route_gw; do
                if [ -n "${route_gw}" ]; then
                    logger -p info -t ${TAG} "Removing IPv4 default route via ${route_gw}"
                    route delete default "${route_gw}" 2>/dev/null || true
                fi
            done
            ;;
        "ipv6")
            get_default_routes "ipv6" | while read route_gw; do
                if [ -n "${route_gw}" ]; then
                    logger -p info -t ${TAG} "Removing IPv6 default route via ${route_gw}"
                    route -6 delete default "${route_gw}" 2>/dev/null || true
                fi
            done
            ;;
    esac
}

manage_routes() {
    if [ "${ENABLE_ROUTE_MANAGEMENT}" != "yes" ]; then
        debug_log "Route management disabled, skipping"
        return
    fi
    
    logger -p info -t ${TAG} "Managing backup routes for CARP status: ${CARP_STATUS}"
    
    # Check current route status
    if check_route_exists "${ALT_DEFROUTE_IPV4}" "ipv4"; then
        local ipv4_alt_route_exists=true
    else
        local ipv4_alt_route_exists=false
    fi
    
    if [ "${ENABLE_IPV6}" = "yes" ] && check_route_exists "${ALT_DEFROUTE_IPV6}" "ipv6"; then
        local ipv6_alt_route_exists=true
    else
        local ipv6_alt_route_exists=false
    fi
    
    debug_log "IPv4 alt route exists: ${ipv4_alt_route_exists}, IPv6 alt route exists: ${ipv6_alt_route_exists}"
    
    case "${CARP_STATUS}" in
        "MASTER")
            # Remove any backup routes when becoming master (normal routing will be restored)
            logger -p info -t ${TAG} "Removing backup routes (becoming MASTER)"
            
            if check_route_exists "${ALT_DEFROUTE_IPV4}" "ipv4"; then
                logger -p info -t ${TAG} "Removing IPv4 backup route via ${ALT_DEFROUTE_IPV4}"
                route delete default "${ALT_DEFROUTE_IPV4}" 2>/dev/null || true
            fi
            
            if [ "${ENABLE_IPV6}" = "yes" ] && check_route_exists "${ALT_DEFROUTE_IPV6}" "ipv6"; then
                logger -p info -t ${TAG} "Removing IPv6 backup route via ${ALT_DEFROUTE_IPV6}"
                route -6 delete default "${ALT_DEFROUTE_IPV6}" 2>/dev/null || true
            fi
            ;;
        "BACKUP")
            # For BACKUP state, remove existing default routes and add backup routes
            logger -p info -t ${TAG} "Configuring backup routing (removing current defaults, adding backup routes)"
            
            # Remove existing default routes first
            remove_default_routes "ipv4"
            if [ "${ENABLE_IPV6}" = "yes" ]; then
                remove_default_routes "ipv6"
            fi
            
            # Wait a moment for route table to settle
            sleep 1
            
            # Add backup routes
            logger -p info -t ${TAG} "Adding IPv4 backup default route via ${ALT_DEFROUTE_IPV4}"
            route add default "${ALT_DEFROUTE_IPV4}" 2>/dev/null || \
                logger -p warning -t ${TAG} "Failed to add IPv4 backup route"
            
            if [ "${ENABLE_IPV6}" = "yes" ]; then
                logger -p info -t ${TAG} "Adding IPv6 backup default route via ${ALT_DEFROUTE_IPV6}"
                route -6 add default "${ALT_DEFROUTE_IPV6}" 2>/dev/null || \
                    logger -p warning -t ${TAG} "Failed to add IPv6 backup route"
            fi
            ;;
    esac
}

# IPv6 integration functions
trigger_ipv6_updates() {
    if [ "${ENABLE_IPV6}" != "yes" ]; then
        return
    fi
    
    # Trigger IPv6 prefix delegation updates if scripts exist
    if [ -x "/usr/local/bin/dhcp6c-ula-mapping.py" ]; then
        debug_log "Triggering IPv6 prefix updates"
        /usr/local/bin/dhcp6c-ula-mapping.py 2>/dev/null || true
    fi
    
    # Update CARP service status for IPv6
    if [ -x "/usr/local/bin/configctl" ]; then
        configctl interface update carp service_status 2>/dev/null || true
    fi
}

# Health check function
perform_health_checks() {
    local exit_code=0
    
    # Check if critical interfaces exist
    for WAN_INT in ${WAN_INTS}; do
        if ! ifconfig "${WAN_INT}" >/dev/null 2>&1; then
            logger -p error -t ${TAG} "Critical interface ${WAN_INT} missing"
            exit_code=1
        fi
    done
    
    # Check if we're in a reasonable state
    if [ "${CARP_STATUS}" = "MASTER" ]; then
        for WAN_INT in ${WAN_INTS}; do
            if [ "$(get_interface_status "${WAN_INT}")" = "DOWN" ]; then
                logger -p warning -t ${TAG} "Master node has interface ${WAN_INT} down"
            fi
        done
    fi
    
    return ${exit_code}
}

# Main execution
main() {
    logger -p info -t ${TAG} "Starting HA failover processing"
    
    # Perform health checks
    if ! perform_health_checks; then
        logger -p error -t ${TAG} "Health checks failed, continuing with limited functionality"
    fi
    
    # Execute management functions in correct order
    manage_wan_interfaces
    
    # Wait for interface changes to settle before managing services
    if [ "${CARP_STATUS}" = "MASTER" ]; then
        debug_log "Waiting ${INTERFACE_SETTLE_TIME} seconds for interface changes to settle"
        sleep "${INTERFACE_SETTLE_TIME}"
    fi
    
    manage_services
    manage_routes
    trigger_ipv6_updates
    
    # Update CARP service status (OPNsense HA health monitoring integration)
    if command -v configctl >/dev/null 2>&1; then
        logger -p debug -t ${TAG} "Updating CARP service status"
        configctl interface update carp service_status 2>/dev/null || true
    fi
    
    logger -p info -t ${TAG} "HA failover processing completed successfully"
}

# Execute main function
main

