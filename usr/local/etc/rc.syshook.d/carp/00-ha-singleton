#!/bin/sh

# OPNsense HA Singleton CARP Hook Script
# Manages interface states, services, and routing based on CARP status
# Version: 2.7 - Added route verification and retry logic for failback scenarios
#
# Implementation Notes:
# - Complete configctl interface linkup.start/stop with verification and ifconfig fallback
# - Handles both MASTER (UP) and BACKUP (DOWN) interface transitions reliably  
# - Added interface reconfiguration for DHCP lease renewal and route restoration
# - Uses configctl interface reconfigure/newip to restore full interface state
# - Enhanced route management: removes existing default routes before adding backup routes
# - Fixes "route already in table" errors by properly managing route table
# - Enhanced IPv6 service restart during CARP state transitions
# - Added route verification and retry logic to ensure failback routing works
# - Compatible with interface_suspend() patterns used in OPNsense 20-ppp hook

TAG="syshook-carp-ha-singleton"
LOCKFILE="/var/run/${TAG}.lock"
CONFIG_FILE="/usr/local/etc/ha-singleton.conf"

# Script arguments
INTERFACE=$1
CARP_STATUS=$2

# Default configuration (overridden by config file if it exists)
WAN_INTS="__INT_LIST__"
WAN_INTERFACE_MAP="wan:vtnet0_vlan110"  # Format: opnsense_name:device_name
SERVICES="rtsold dhcp6c radvd"
ALT_DEFROUTE_IPV4="192.168.105.2"
ALT_DEFROUTE_IPV6="fd03:17ac:e938:10::2"
ENABLE_IPV6="yes"
ENABLE_SERVICE_MANAGEMENT="yes"
ENABLE_ROUTE_MANAGEMENT="yes"
ENABLE_INTERFACE_RECONFIGURE="yes"

# Route verification and retry configuration (NEW in v2.7)
# These settings address ARP resolution issues and timing problems during failback
ENABLE_ROUTE_VERIFICATION="yes"        # Enable route verification and automatic fixing
ROUTE_RETRY_COUNT="3"                   # Number of times to retry route operations
ROUTE_RETRY_DELAY="2"                   # Seconds between route retry attempts

# DHCPv6 DUID override configuration (NEW in v2.7)
# Essential for consistent DHCPv6 client identification in HA setups
ENABLE_DHCP6C_DUID_OVERRIDE="yes"       # Enable DUID override functionality
DHCP6C_DUID_OVERRIDE_FILE="/conf/dhcp6c_duid.override"  # Custom DUID file location
DHCP6C_DUID_SYSTEM_FILE="/var/db/dhcp6c_duid"           # System DUID file location
DHCP6C_DUID_BACKUP_FILE="/conf/dhcp6c_duid"             # OPNsense backup DUID location

DEBUG="no"

# Load configuration file if it exists
if [ -f "${CONFIG_FILE}" ]; then
    . "${CONFIG_FILE}"
fi



# Lock management functions
acquire_lock() {
    if [ -f "${LOCKFILE}" ]; then
        local pid=$(cat "${LOCKFILE}")
        if ps -p "${pid}" > /dev/null 2>&1; then
            logger -p warning -t ${TAG} "Script already running (PID: ${pid}), exiting"
            exit 0
        else
            logger -p info -t ${TAG} "Removing stale lock file"
            rm -f "${LOCKFILE}"
        fi
    fi
    echo $$ > "${LOCKFILE}"
}

release_lock() {
    rm -f "${LOCKFILE}"
}

# Set up exit trap
trap release_lock EXIT

# Validation and initialization
validate_environment() {
    if [ -z "${INTERFACE}" ] || [ -z "${CARP_STATUS}" ]; then
        logger -p error -t ${TAG} "Missing required environment variables: INTERFACE=${INTERFACE} CARP_STATUS=${CARP_STATUS}"
        exit 1
    fi
    
    # Normalize CARP status
    case "${CARP_STATUS}" in
        "MASTER")
            ;;
        "BACKUP")
            ;;
        "INIT")
            logger -p info -t ${TAG} "CARP in INIT state, treating as BACKUP"
            CARP_STATUS="BACKUP"
            ;;
        *)
            logger -p warning -t ${TAG} "Unknown CARP status: ${CARP_STATUS}, treating as BACKUP"
            CARP_STATUS="BACKUP"
            ;;
    esac
}

# Debug logging function
debug_log() {
    if [ "${DEBUG}" = "yes" ]; then
        logger -p info -t ${TAG} "[DEBUG] $1"
    fi
}

# System tunable initialization
init_system_tunables() {
    # Disable PFSYNC CARP demotion to prevent flapping during primary failures
    local current_factor=$(sysctl -n net.pfsync.carp_demotion_factor 2>/dev/null || echo "240")
    if [ "${current_factor}" != "0" ]; then
        logger -p info -t ${TAG} "Setting PFSYNC CARP demotion factor to 0 (was ${current_factor})"
        sysctl net.pfsync.carp_demotion_factor=0 >/dev/null 2>&1 || \
            logger -p warning -t ${TAG} "Failed to set PFSYNC demotion factor"
    fi
}

# Initialize
acquire_lock
validate_environment
init_system_tunables

logger -p info -t ${TAG} "Processing CARP event: ${INTERFACE} -> ${CARP_STATUS}"
debug_log "Configuration: WAN_INTS=${WAN_INTS}, IPv6=${ENABLE_IPV6}, Services=${ENABLE_SERVICE_MANAGEMENT}"

# Interface management functions
get_interface_status() {
    local interface=$1
    if ifconfig -l -u | grep -q "${interface}"; then
        echo "UP"
    else
        echo "DOWN"
    fi
}

# Map device name to OPNsense interface name for configctl commands
get_opnsense_interface_name() {
    local device_name=$1
    
    # Parse WAN_INTERFACE_MAP format: "opnsense_name:device_name"
    echo "${WAN_INTERFACE_MAP}" | tr ' ' '\n' | while read mapping; do
        if [ -n "${mapping}" ]; then
            local opnsense_name=$(echo "${mapping}" | cut -d':' -f1)
            local device=$(echo "${mapping}" | cut -d':' -f2)
            if [ "${device}" = "${device_name}" ]; then
                echo "${opnsense_name}"
                return
            fi
        fi
    done
    
    # Default fallback: assume 'wan' if no mapping found
    echo "wan"
}

manage_wan_interfaces() {
    logger -p info -t ${TAG} "Managing WAN interfaces for CARP status: ${CARP_STATUS}"
    
    for WAN_INT in ${WAN_INTS}; do
        # Validate interface exists
        if ! ifconfig "${WAN_INT}" >/dev/null 2>&1; then
            logger -p warning -t ${TAG} "Interface ${WAN_INT} does not exist, skipping"
            continue
        fi
        
        local cur_status=$(get_interface_status "${WAN_INT}")
        debug_log "Interface ${WAN_INT} current status: ${cur_status}"
        
        case "${CARP_STATUS}" in
            "MASTER")
                if [ "${cur_status}" = "DOWN" ]; then
                    logger -p info -t ${TAG} "Bringing up ${WAN_INT} (CARP MASTER)"
                    # Try configctl first, then fall back to ifconfig
                    if ! configctl interface linkup.start "${WAN_INT}" >/dev/null 2>&1; then
                        logger -p info -t ${TAG} "configctl not available, using ifconfig for ${WAN_INT}"
                        ifconfig "${WAN_INT}" up
                    else
                        # Verify the interface came up
                        sleep 1
                        if [ "$(get_interface_status "${WAN_INT}")" = "DOWN" ]; then
                            logger -p warning -t ${TAG} "configctl failed to bring up ${WAN_INT}, using ifconfig"
                            ifconfig "${WAN_INT}" up
                        fi
                    fi
                    
                    # Critical: Trigger OPNsense interface reconfiguration for DHCP renewal and routing
                    if [ "${ENABLE_INTERFACE_RECONFIGURE}" = "yes" ]; then
                        local opnsense_interface=$(get_opnsense_interface_name "${WAN_INT}")
                        logger -p info -t ${TAG} "Triggering interface reconfiguration for ${WAN_INT} (${opnsense_interface})"
                        
                        if ! configctl interface reconfigure "${opnsense_interface}" >/dev/null 2>&1; then
                            logger -p warning -t ${TAG} "configctl interface reconfigure failed, triggering newip event"
                            # Fallback: trigger newip event to restore DHCP lease and routes
                            configctl interface newip "${opnsense_interface}" force >/dev/null 2>&1 || \
                                logger -p warning -t ${TAG} "Failed to trigger newip event for ${WAN_INT}"
                        fi
                    else
                        debug_log "Interface reconfiguration disabled, skipping DHCP renewal"
                    fi
                else
                    debug_log "${WAN_INT} already UP, no action needed"
                fi
                ;;
            "BACKUP")
                if [ "${cur_status}" = "UP" ]; then
                    logger -p info -t ${TAG} "Bringing down ${WAN_INT} (CARP BACKUP)"
                    # Try configctl first, then fall back to ifconfig 
                    if ! configctl interface linkup.stop "${WAN_INT}" >/dev/null 2>&1; then
                        logger -p info -t ${TAG} "configctl not available, using ifconfig for ${WAN_INT}"
                        ifconfig "${WAN_INT}" down
                    else
                        # Verify the interface went down
                        sleep 1
                        if [ "$(get_interface_status "${WAN_INT}")" = "UP" ]; then
                            logger -p warning -t ${TAG} "configctl failed to bring down ${WAN_INT}, using ifconfig"
                            ifconfig "${WAN_INT}" down
                        fi
                    fi
                else
                    debug_log "${WAN_INT} already DOWN, no action needed"
                fi
                ;;
        esac
    done
}

# Service management functions
check_service_status() {
    local service=$1
    service "${service}" status >/dev/null 2>&1
    return $?
}

start_service() {
    local service=$1
    logger -p info -t ${TAG} "Starting service: ${service}"
    
    # Skip configctl for IPv6 services that don't have configctl actions
    case "${service}" in
        rtsold|dhcp6c|radvd)
            # Use direct daemon commands for IPv6 services
            case "${service}" in
                rtsold)
                    # Use conditional rtsold scripts based on CARP state
                    if [ "${CARP_STATUS}" = "MASTER" ]; then
                        # Full rtsold with scripts for proper IPv6 operation
                        /usr/sbin/rtsold -aiu -p /var/run/rtsold.pid -A /var/etc/rtsold_script.sh -R /usr/local/opnsense/scripts/interfaces/rtsold_resolvconf.sh
                    else
                        # Minimal rtsold for BACKUP state to avoid interface conflicts
                        /usr/sbin/rtsold -aiu -p /var/run/rtsold.pid
                    fi
                    ;;
                radvd)
                    /usr/local/sbin/radvd -p /var/run/radvd.pid -C /var/etc/radvd.conf -m syslog
                    ;;
                dhcp6c)
                    # Enhanced dhcp6c startup with interface validation
                    local dhcp6c_config="/var/etc/dhcp6c.conf"
                    if [ -f "${dhcp6c_config}" ]; then
                        # Kill any existing dhcp6c processes that might be stuck
                        pkill -f dhcp6c 2>/dev/null || true
                        sleep 1
                        # Start dhcp6c with fresh configuration
                        /usr/local/sbin/dhcp6c -c "${dhcp6c_config}" -p /var/run/dhcp6c.pid
                        debug_log "Started dhcp6c with config: ${dhcp6c_config}"
                    else
                        logger -p warning -t ${TAG} "dhcp6c config file not found: ${dhcp6c_config}"
                    fi
                    ;;
            esac
            ;;
        *)
            # Try configctl for other services
            if ! configctl "${service}" start 2>/dev/null; then
                logger -p warning -t ${TAG} "Unknown service for configctl: ${service}"
                return 1
            fi
            ;;
    esac
}

stop_service() {
    local service=$1
    logger -p info -t ${TAG} "Stopping service: ${service}"
    
    # Skip configctl for IPv6 services that don't have configctl actions  
    case "${service}" in
        rtsold|dhcp6c|radvd)
            # Use FreeBSD service management for IPv6 services
            service "${service}" onestop
            ;;
        *)
            # Try configctl for other services
            if ! configctl "${service}" stop 2>/dev/null; then
                service "${service}" onestop
            fi
            ;;
    esac
}

restart_service() {
    local service=$1
    logger -p info -t ${TAG} "Restarting service: ${service}"
    
    # For IPv6 services, we need to restart them to rebind to correct interfaces
    case "${service}" in
        rtsold|dhcp6c|radvd)
            # Stop the service first
            service "${service}" onestop 2>/dev/null || true
            # Wait a moment for cleanup
            sleep 1
            # Start with fresh interface bindings
            start_service "${service}"
            ;;
        *)
            # Try configctl restart or fall back to service restart
            if ! configctl "${service}" restart 2>/dev/null; then
                service "${service}" onerestart 2>/dev/null || service "${service}" restart
            fi
            ;;
    esac
}

manage_services() {
    if [ "${ENABLE_SERVICE_MANAGEMENT}" != "yes" ]; then
        debug_log "Service management disabled, skipping"
        return
    fi
    
    logger -p info -t ${TAG} "Managing services for CARP status: ${CARP_STATUS}"
    
    for service in ${SERVICES}; do
        if check_service_status "${service}"; then
            local service_running=true
        else
            local service_running=false
        fi
        
        debug_log "Service ${service} running: ${service_running}"
        
        case "${CARP_STATUS}" in
            "MASTER")
                if [ "${service_running}" = "false" ]; then
                    start_service "${service}"
                else
                    # Critical fix: Restart IPv6 services when becoming MASTER
                    # This ensures they rebind to the correct interfaces
                    case "${service}" in
                        rtsold|dhcp6c|radvd)
                            logger -p info -t ${TAG} "Restarting ${service} for interface rebinding"
                            restart_service "${service}"
                            ;;
                        *)
                            debug_log "Service ${service} already running"
                            ;;
                    esac
                fi
                ;;
            "BACKUP")
                if [ "${service_running}" = "true" ]; then
                    stop_service "${service}"
                else
                    debug_log "Service ${service} already stopped"
                fi
                ;;
        esac
    done
}

# Route management functions
verify_default_route() {
    local expected_gateway=$1
    local family=$2
    local max_retries=${3:-${ROUTE_RETRY_COUNT}}
    local retry_delay=${4:-${ROUTE_RETRY_DELAY}}
    
    logger -p info -t ${TAG} "Verifying ${family} default route to ${expected_gateway}"
    
    local attempt=1
    while [ ${attempt} -le ${max_retries} ]; do
        if check_route_exists "${expected_gateway}" "${family}"; then
            logger -p info -t ${TAG} "Verified ${family} default route to ${expected_gateway} (attempt ${attempt})"
            return 0
        fi
        
        logger -p warning -t ${TAG} "Default route verification failed (attempt ${attempt}/${max_retries})"
        
        if [ ${attempt} -lt ${max_retries} ]; then
            # Try to add the route manually
            logger -p info -t ${TAG} "Attempting to add ${family} default route via ${expected_gateway}"
            case "${family}" in
                "ipv4")
                    route add default "${expected_gateway}" 2>/dev/null || \
                        logger -p warning -t ${TAG} "Failed to manually add IPv4 route"
                    ;;
                "ipv6")
                    route -6 add default "${expected_gateway}" 2>/dev/null || \
                        logger -p warning -t ${TAG} "Failed to manually add IPv6 route"
                    ;;
            esac
            
            logger -p info -t ${TAG} "Waiting ${retry_delay} seconds before retry"
            sleep ${retry_delay}
        fi
        
        attempt=$((attempt + 1))
    done
    
    logger -p error -t ${TAG} "Failed to verify ${family} default route after ${max_retries} attempts"
    return 1
}

force_arp_resolution() {
    local gateway=$1
    local interface=$2
    
    logger -p info -t ${TAG} "Forcing ARP resolution for gateway ${gateway} via ${interface}"
    
    # Send ping to force ARP resolution
    ping -c 1 -W 2000 -S "${interface}" "${gateway}" >/dev/null 2>&1 || \
        logger -p warning -t ${TAG} "ARP resolution ping failed for ${gateway}"
    
    # Check if ARP entry exists
    if arp -n "${gateway}" >/dev/null 2>&1; then
        logger -p info -t ${TAG} "ARP entry confirmed for ${gateway}"
        return 0
    else
        logger -p warning -t ${TAG} "No ARP entry found for ${gateway}"
        return 1
    fi
}

get_interface_gateway() {
    local interface=$1
    local family=$2
    
    case "${family}" in
        "ipv4")
            # Get IPv4 gateway from routing table for this interface
            netstat -rn -f inet | awk -v iface="${interface}" '$6 == iface && /^default/ {print $2}' | head -1
            ;;
        "ipv6")
            # Get IPv6 gateway from routing table for this interface
            netstat -rn -f inet6 | awk -v iface="${interface}" '$4 == iface && /^default/ {print $2}' | head -1
            ;;
    esac
}

verify_and_fix_master_routes() {
    if [ "${ENABLE_ROUTE_VERIFICATION}" != "yes" ]; then
        debug_log "Route verification disabled, skipping"
        return
    fi
    
    logger -p info -t ${TAG} "Verifying and fixing MASTER routes after interface reconfiguration"
    
    # Wait for interface configuration to settle
    sleep ${ROUTE_RETRY_DELAY}
    
    # Check each WAN interface for proper routing
    for WAN_INT in ${WAN_INTS}; do
        if [ "$(get_interface_status "${WAN_INT}")" = "UP" ]; then
            logger -p info -t ${TAG} "Checking routes for interface ${WAN_INT}"
            
            # Get the expected gateway for this interface
            local ipv4_gw=$(get_interface_gateway "${WAN_INT}" "ipv4")
            
            if [ -n "${ipv4_gw}" ]; then
                logger -p info -t ${TAG} "Expected IPv4 gateway for ${WAN_INT}: ${ipv4_gw}"
                
                # Force ARP resolution first
                force_arp_resolution "${ipv4_gw}" "${WAN_INT}"
                
                # Verify the route exists and is working
                if ! verify_default_route "${ipv4_gw}" "ipv4"; then
                    logger -p warning -t ${TAG} "IPv4 route verification failed for ${WAN_INT}, triggering interface reset"
                    
                    # Try to reset the interface completely
                    local opnsense_interface=$(get_opnsense_interface_name "${WAN_INT}")
                    logger -p info -t ${TAG} "Triggering emergency interface reset for ${WAN_INT} (${opnsense_interface})"
                    
                    # Force interface down/up cycle
                    ifconfig "${WAN_INT}" down
                    sleep 1
                    ifconfig "${WAN_INT}" up
                    sleep 2
                    
                    # Trigger configctl reconfiguration again
                    configctl interface reconfigure "${opnsense_interface}" >/dev/null 2>&1 || \
                        configctl interface newip "${opnsense_interface}" force >/dev/null 2>&1
                    
                    # Wait and verify again
                    sleep ${ROUTE_RETRY_DELAY}
                    
                    # Get updated gateway info
                    ipv4_gw=$(get_interface_gateway "${WAN_INT}" "ipv4")
                    if [ -n "${ipv4_gw}" ]; then
                        force_arp_resolution "${ipv4_gw}" "${WAN_INT}"
                        verify_default_route "${ipv4_gw}" "ipv4" 1 1 || \
                            logger -p error -t ${TAG} "Emergency route fix failed for ${WAN_INT}"
                    fi
                fi
            else
                logger -p warning -t ${TAG} "No IPv4 gateway found for ${WAN_INT}"
            fi
            
            # Handle IPv6 if enabled
            if [ "${ENABLE_IPV6}" = "yes" ]; then
                local ipv6_gw=$(get_interface_gateway "${WAN_INT}" "ipv6")
                if [ -n "${ipv6_gw}" ]; then
                    logger -p info -t ${TAG} "Verifying IPv6 gateway for ${WAN_INT}: ${ipv6_gw}"
                    verify_default_route "${ipv6_gw}" "ipv6" 2 1 || \
                        logger -p warning -t ${TAG} "IPv6 route verification failed for ${WAN_INT}"
                fi
            fi
        fi
    done
}

check_route_exists() {
    local gateway=$1
    local family=$2
    
    case "${family}" in
        "ipv4")
            # Check if default route exists via this gateway
            netstat -rn -f inet | grep "^default" | grep -q "${gateway}"
            return $?
            ;;
        "ipv6")
            # Check if default IPv6 route exists via this gateway
            netstat -rn -f inet6 | grep "^default" | grep -q "${gateway}"
            return $?
            ;;
    esac
    return 1
}

get_default_routes() {
    local family=$1
    case "${family}" in
        "ipv4")
            netstat -rn -f inet | awk '/^default/ {print $2}'
            ;;
        "ipv6")
            netstat -rn -f inet6 | awk '/^default/ {print $2}'
            ;;
        *)
            return 1
            ;;
    esac
}

check_route_exists() {
    local route_ip=$1
    local family=$2
    
    case "${family}" in
        "ipv4")
            netstat -rn -f inet | grep -q "default.*${route_ip}"
            ;;
        "ipv6")
            netstat -rn -f inet6 | grep -q "default.*${route_ip}"
            ;;
        *)
            return 1
            ;;
    esac
}

remove_default_routes() {
    local family=$1
    
    logger -p info -t ${TAG} "Removing existing ${family} default routes"
    
    case "${family}" in
        "ipv4")
            get_default_routes "ipv4" | while read route_gw; do
                if [ -n "${route_gw}" ]; then
                    logger -p info -t ${TAG} "Removing IPv4 default route via ${route_gw}"
                    route delete default "${route_gw}" 2>/dev/null || true
                fi
            done
            ;;
        "ipv6")
            get_default_routes "ipv6" | while read route_gw; do
                if [ -n "${route_gw}" ]; then
                    logger -p info -t ${TAG} "Removing IPv6 default route via ${route_gw}"
                    route -6 delete default "${route_gw}" 2>/dev/null || true
                fi
            done
            ;;
    esac
}

manage_routes() {
    if [ "${ENABLE_ROUTE_MANAGEMENT}" != "yes" ]; then
        debug_log "Route management disabled, skipping"
        return
    fi
    
    logger -p info -t ${TAG} "Managing backup routes for CARP status: ${CARP_STATUS}"
    
    # Check current route status
    if check_route_exists "${ALT_DEFROUTE_IPV4}" "ipv4"; then
        local ipv4_alt_route_exists=true
    else
        local ipv4_alt_route_exists=false
    fi
    
    if [ "${ENABLE_IPV6}" = "yes" ] && check_route_exists "${ALT_DEFROUTE_IPV6}" "ipv6"; then
        local ipv6_alt_route_exists=true
    else
        local ipv6_alt_route_exists=false
    fi
    
    debug_log "IPv4 alt route exists: ${ipv4_alt_route_exists}, IPv6 alt route exists: ${ipv6_alt_route_exists}"
    
    case "${CARP_STATUS}" in
        "MASTER")
            # Remove any backup routes when becoming master (normal routing will be restored)
            logger -p info -t ${TAG} "Removing backup routes (becoming MASTER)"
            
            if check_route_exists "${ALT_DEFROUTE_IPV4}" "ipv4"; then
                logger -p info -t ${TAG} "Removing IPv4 backup route via ${ALT_DEFROUTE_IPV4}"
                route delete default "${ALT_DEFROUTE_IPV4}" 2>/dev/null || true
            fi
            
            if [ "${ENABLE_IPV6}" = "yes" ] && check_route_exists "${ALT_DEFROUTE_IPV6}" "ipv6"; then
                logger -p info -t ${TAG} "Removing IPv6 backup route via ${ALT_DEFROUTE_IPV6}"
                route -6 delete default "${ALT_DEFROUTE_IPV6}" 2>/dev/null || true
            fi
            
            # Verify that proper MASTER routes are established after interface reconfiguration
            verify_and_fix_master_routes
            ;;
        "BACKUP")
            # For BACKUP state, remove existing default routes and add backup routes
            logger -p info -t ${TAG} "Configuring backup routing (removing current defaults, adding backup routes)"
            
            # Remove existing default routes first
            remove_default_routes "ipv4"
            if [ "${ENABLE_IPV6}" = "yes" ]; then
                remove_default_routes "ipv6"
            fi
            
            # Wait a moment for route table to settle
            sleep 1
            
            # Add backup routes
            logger -p info -t ${TAG} "Adding IPv4 backup default route via ${ALT_DEFROUTE_IPV4}"
            route add default "${ALT_DEFROUTE_IPV4}" 2>/dev/null || \
                logger -p warning -t ${TAG} "Failed to add IPv4 backup route"
            
            if [ "${ENABLE_IPV6}" = "yes" ]; then
                logger -p info -t ${TAG} "Adding IPv6 backup default route via ${ALT_DEFROUTE_IPV6}"
                route -6 add default "${ALT_DEFROUTE_IPV6}" 2>/dev/null || \
                    logger -p warning -t ${TAG} "Failed to add IPv6 backup route"
            fi
            ;;
    esac
}

# IPv6 integration functions
trigger_ipv6_updates() {
    if [ "${ENABLE_IPV6}" != "yes" ]; then
        return
    fi
    
    # Trigger IPv6 prefix delegation updates if scripts exist
    if [ -x "/usr/local/bin/dhcp6c-ula-mapping.py" ]; then
        debug_log "Triggering IPv6 prefix updates"
        /usr/local/bin/dhcp6c-ula-mapping.py 2>/dev/null || true
    fi
    
    # Update CARP service status for IPv6
    if [ -x "/usr/local/bin/configctl" ]; then
        configctl interface update carp service_status 2>/dev/null || true
    fi
}

# Health check function
perform_health_checks() {
    local exit_code=0
    
    # Check if critical interfaces exist
    for WAN_INT in ${WAN_INTS}; do
        if ! ifconfig "${WAN_INT}" >/dev/null 2>&1; then
            logger -p error -t ${TAG} "Critical interface ${WAN_INT} missing"
            exit_code=1
        fi
    done
    
    # Check if we're in a reasonable state
    if [ "${CARP_STATUS}" = "MASTER" ]; then
        for WAN_INT in ${WAN_INTS}; do
            if [ "$(get_interface_status "${WAN_INT}")" = "DOWN" ]; then
                logger -p warning -t ${TAG} "Master node has interface ${WAN_INT} down"
            fi
        done
    fi
    
    return ${exit_code}
}

# Main execution
main() {
    logger -p info -t ${TAG} "Starting HA failover processing"
    
    # Perform health checks
    if ! perform_health_checks; then
        logger -p error -t ${TAG} "Health checks failed, continuing with limited functionality"
    fi
    
    # Execute management functions in correct order
    manage_wan_interfaces
    
    # Wait for interface changes to settle before managing services
    if [ "${CARP_STATUS}" = "MASTER" ]; then
        debug_log "Waiting ${INTERFACE_SETTLE_TIME} seconds for interface changes to settle"
        sleep "${INTERFACE_SETTLE_TIME}"
    fi
    
    manage_services
    manage_routes
    trigger_ipv6_updates
    
    # Update CARP service status (OPNsense HA health monitoring integration)
    if command -v configctl >/dev/null 2>&1; then
        logger -p debug -t ${TAG} "Updating CARP service status"
        configctl interface update carp service_status 2>/dev/null || true
    fi
    
    logger -p info -t ${TAG} "HA failover processing completed successfully"
}

# Execute main function
main

