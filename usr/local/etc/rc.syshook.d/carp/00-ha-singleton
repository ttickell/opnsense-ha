#!/bin/sh

# OPNsense HA Singleton CARP Hook Script
# Manages interface states, services, and routing based on CARP status
# Version: 3.0 - Phase 3 IPv6 HA Integration (Advanced Connectivity Monitoring)
#
# Implementation Notes:
# - Complete interface management via direct rc.linkup with verification and ifconfig fallback
# - Handles both MASTER (UP) and BACKUP (DOWN) interface transitions reliably  
# - Added interface reconfiguration for DHCP lease renewal and route restoration
# - Uses direct rc.configure_interface/rc.newwanip to restore full interface state
# - Enhanced route management: removes existing default routes before adding backup routes
# - Fixes "route already in table" errors by properly managing route table
# - Enhanced IPv6 service restart during CARP state transitions
# - Added route verification and retry logic to ensure failback routing works
# - Added DHCP lease clearing to address cable modem stale lease issues
# - IPv6 HA Integration: delegation processing, ULA mapping, state management
# - Compatible with interface_suspend() patterns used in OPNsense 20-ppp hook

TAG="syshook-carp-ha-singleton"
LOCKFILE="/var/run/${TAG}.lock"
CONFIG_FILE="/usr/local/etc/ha-singleton.conf"

# Script arguments
INTERFACE=$1
CARP_STATUS=$2

# Default configuration (overridden by config file if it exists)
WAN_INTS="__INT_LIST__"
WAN_INTERFACE_MAP="wan:vtnet0_vlan110"  # Format: opnsense_name:device_name
SERVICES="rtsold dhcp6c radvd"
ALT_DEFROUTE_IPV4="192.168.105.2"
ALT_DEFROUTE_IPV6="fd03:17ac:e938:10::2"
ENABLE_IPV6="yes"
ENABLE_SERVICE_MANAGEMENT="yes"
ENABLE_ROUTE_MANAGEMENT="yes"
ENABLE_INTERFACE_RECONFIGURE="yes"
ENABLE_DHCP_LEASE_CLEARING="yes"        # Clear stale DHCP leases before interface restart

# IPv6 HA Integration Configuration (NEW in v2.8, Enhanced in v2.9)
ENABLE_IPV6_HA_MANAGEMENT="yes"         # Enable IPv6 HA-specific management
ENABLE_IPV6_DELEGATION_PROCESSING="yes" # Process IPv6 prefix delegations during CARP transitions
ENABLE_ULA_MAPPING_MANAGEMENT="yes"     # Manage ULA to delegation mappings
ENABLE_DYNAMIC_NPTV6="no"              # Dynamic NPTv6 rule management (Phase 3)
IPV6_ULA_PREFIX="fd03:17ac:e938::/48"   # ULA prefix for internal networks
IPV6_STATE_DIR="/var/db/ipv6-ha"       # IPv6 HA state directory
IPV6_DELEGATION_TIMEOUT="30"           # Timeout for IPv6 delegation validation (seconds)

# Phase 2 IPv6 Enhancements (NEW in v2.9)
ENABLE_IPV6_ROUTER_ADVERTISEMENTS="yes" # Manage radvd service during CARP transitions
ENABLE_IPV6_DHCP_SERVER="yes"          # Manage DHCPv6 server during CARP transitions
ENABLE_IPV6_INTERFACE_RECONFIGURE="yes" # Enhanced IPv6 interface reconfiguration
IPV6_TEST_ADDRESS="2001:4860:4860::8888" # IPv6 connectivity test address (Google DNS)
IPV6_DELEGATION_REFRESH_INTERVAL="300"  # Refresh delegations every 5 minutes when stale

# Phase 3 IPv6 Advanced Features (NEW in v3.0)
ENABLE_IPV6_CONNECTIVITY_MONITORING="yes" # Advanced IPv6 connectivity monitoring and health assessment
IPV6_MONITORING_INTERVAL="30"           # Connectivity check interval in seconds
IPV6_FAILOVER_THRESHOLD="3"             # Consecutive failures before triggering failover consideration

# Route verification and retry configuration (NEW in v2.7)
# These settings address ARP resolution issues and timing problems during failback
ENABLE_ROUTE_VERIFICATION="yes"        # Enable route verification and automatic fixing
ROUTE_RETRY_COUNT="3"                   # Number of times to retry route operations
ROUTE_RETRY_DELAY="2"                   # Seconds between route retry attempts

# Interface timing configuration
INTERFACE_SETTLE_TIME="2"               # Seconds to wait for interface changes to settle

DEBUG="no"

# Load configuration file if it exists
if [ -f "${CONFIG_FILE}" ]; then
    . "${CONFIG_FILE}"
fi



# Lock management functions
acquire_lock() {
    if [ -f "${LOCKFILE}" ]; then
        local pid=$(cat "${LOCKFILE}")
        if ps -p "${pid}" > /dev/null 2>&1; then
            logger -p warning -t ${TAG} "Script already running (PID: ${pid}), exiting"
            exit 0
        else
            logger -p info -t ${TAG} "Removing stale lock file"
            rm -f "${LOCKFILE}"
        fi
    fi
    echo $$ > "${LOCKFILE}"
}

release_lock() {
    rm -f "${LOCKFILE}"
}

# Set up exit trap
trap release_lock EXIT

# Validation and initialization
validate_environment() {
    if [ -z "${INTERFACE}" ] || [ -z "${CARP_STATUS}" ]; then
        logger -p error -t ${TAG} "Missing required environment variables: INTERFACE=${INTERFACE} CARP_STATUS=${CARP_STATUS}"
        exit 1
    fi
    
    # Normalize CARP status
    case "${CARP_STATUS}" in
        "MASTER")
            ;;
        "BACKUP")
            ;;
        "INIT")
            logger -p info -t ${TAG} "CARP in INIT state, treating as BACKUP"
            CARP_STATUS="BACKUP"
            ;;
        *)
            logger -p warning -t ${TAG} "Unknown CARP status: ${CARP_STATUS}, treating as BACKUP"
            CARP_STATUS="BACKUP"
            ;;
    esac
}

# Debug logging function
debug_log() {
    if [ "${DEBUG}" = "yes" ]; then
        logger -p info -t ${TAG} "[DEBUG] $1"
    fi
}

# System tunable initialization
init_system_tunables() {
    # Disable PFSYNC CARP demotion to prevent flapping during primary failures
    local current_factor=$(sysctl -n net.pfsync.carp_demotion_factor 2>/dev/null || echo "240")
    if [ "${current_factor}" != "0" ]; then
        logger -p info -t ${TAG} "Setting PFSYNC CARP demotion factor to 0 (was ${current_factor})"
        sysctl net.pfsync.carp_demotion_factor=0 >/dev/null 2>&1 || \
            logger -p warning -t ${TAG} "Failed to set PFSYNC demotion factor"
    fi
}

# Initialize
acquire_lock
validate_environment
init_system_tunables

logger -p info -t ${TAG} "Processing CARP event: ${INTERFACE} -> ${CARP_STATUS}"
debug_log "Configuration: WAN_INTS=${WAN_INTS}, IPv6=${ENABLE_IPV6}, Services=${ENABLE_SERVICE_MANAGEMENT}"

# IPv6 HA Management Functions
ensure_ipv6_state_directory() {
    if [ "${ENABLE_IPV6_HA_MANAGEMENT}" = "yes" ]; then
        mkdir -p "${IPV6_STATE_DIR}"
        chmod 755 "${IPV6_STATE_DIR}"
        debug_log "Ensured IPv6 state directory exists: ${IPV6_STATE_DIR}"
    fi
}

check_ipv6_delegation_file() {
    local delegation_file="${IPV6_STATE_DIR}/dhcp6c-delegations.json"
    if [ -f "${delegation_file}" ]; then
        # Check if file is recent (within refresh interval for active monitoring)
        local file_age=$(( $(date +%s) - $(stat -f %m "${delegation_file}") ))
        local max_age=${IPV6_DELEGATION_REFRESH_INTERVAL:-300}  # Default 5 minutes
        
        if [ ${file_age} -lt ${max_age} ]; then
            return 0  # File exists and is recent
        else
            debug_log "IPv6 delegation file is stale (age: ${file_age}s, max: ${max_age}s)"
            return 1
        fi
    else
        debug_log "IPv6 delegation file not found: ${delegation_file}"
        return 1
    fi
}

validate_ipv6_delegations() {
    if [ "${ENABLE_IPV6_DELEGATION_PROCESSING}" != "yes" ]; then
        debug_log "IPv6 delegation processing disabled"
        return 0
    fi
    
    local delegation_file="${IPV6_STATE_DIR}/dhcp6c-delegations.json"
    logger -p info -t ${TAG} "Validating IPv6 delegations"
    
    # Ensure state directory exists
    ensure_ipv6_state_directory
    
    # Check if delegation file exists and is recent
    if check_ipv6_delegation_file; then
        logger -p info -t ${TAG} "IPv6 delegations are current"
        return 0
    fi
    
    # Trigger delegation refresh
    if [ -x "/usr/local/bin/dhcp6c-prefix-json" ]; then
        logger -p info -t ${TAG} "Refreshing IPv6 delegation state"
        if /usr/local/bin/dhcp6c-prefix-json >/dev/null 2>&1; then
            logger -p info -t ${TAG} "IPv6 delegation refresh completed"
            return 0
        else
            logger -p warning -t ${TAG} "IPv6 delegation refresh failed"
            return 1
        fi
    else
        logger -p warning -t ${TAG} "IPv6 delegation script not found"
        return 1
    fi
}

trigger_ipv6_ula_mapping_update() {
    if [ "${ENABLE_ULA_MAPPING_MANAGEMENT}" != "yes" ]; then
        debug_log "ULA mapping management disabled"
        return 0
    fi
    
    logger -p info -t ${TAG} "Triggering IPv6 ULA mapping update"
    
    if [ -x "/usr/local/bin/dhcp6c-ula-mapping.py" ]; then
        if /usr/local/bin/dhcp6c-ula-mapping.py >/dev/null 2>&1; then
            logger -p info -t ${TAG} "IPv6 ULA mapping update completed"
            return 0
        else
            logger -p warning -t ${TAG} "IPv6 ULA mapping update failed"
            return 1
        fi
    else
        logger -p warning -t ${TAG} "IPv6 ULA mapping script not found"
        return 1
    fi
}

process_ipv6_carp_transition() {
    if [ "${ENABLE_IPV6_HA_MANAGEMENT}" != "yes" ]; then
        return 0
    fi
    
    logger -p info -t ${TAG} "Processing IPv6 CARP transition: ${CARP_STATUS}"
    
    case "${CARP_STATUS}" in
        "MASTER")
            # Enhanced MASTER transition for IPv6
            validate_ipv6_delegations
            trigger_ipv6_ula_mapping_update
            
            # Manage IPv6-specific services
            manage_ipv6_router_advertisements
            manage_ipv6_dhcp_server
            
            # Configure IPv6 interfaces with current delegations
            configure_ipv6_interfaces
            
            # Start IPv6 connectivity monitoring (Phase 3 Step 5)
            manage_ipv6_monitoring
            ;;
        "BACKUP")
            # Enhanced BACKUP transition for IPv6
            validate_ipv6_delegations
            
            # Stop IPv6 services to prevent conflicts
            manage_ipv6_router_advertisements
            manage_ipv6_dhcp_server
            
            # Deconfigure IPv6 addresses but preserve delegation state
            deconfigure_ipv6_interfaces
            
            # Continue monitoring for failover readiness (Phase 3 Step 5)
            manage_ipv6_monitoring
            ;;
    esac
}

# Enhanced DHCPv6 delegation refresh function  
refresh_dhcp6_delegations() {
    if [ "${ENABLE_IPV6_HA_MANAGEMENT}" != "yes" ]; then
        return 0
    fi
    
    logger -p info -t ${TAG} "Refreshing DHCPv6 prefix delegations"
    
    # Restart DHCPv6 client for each WAN interface with IPv6 enabled
    for WAN_INT in ${WAN_INTS}; do
        local opnsense_interface=$(get_opnsense_interface_name "${WAN_INT}")
        
        # Check if interface has IPv6 configuration in OPNsense
        if configctl interface list | grep -q "${opnsense_interface}"; then
            logger -p info -t ${TAG} "Refreshing DHCPv6 delegation for ${WAN_INT} (${opnsense_interface})"
            
            # Stop and restart DHCPv6 client to force fresh delegation request
            # Note: DHCPv6 client is managed by interface reconfiguration, not direct service control
            logger -p info -t ${TAG} "Triggering interface reconfiguration to refresh DHCPv6 for ${WAN_INT}"
            configctl interface newipv6 "${opnsense_interface}" >/dev/null 2>&1 || \
                logger -p warning -t ${TAG} "Failed to trigger IPv6 reconfiguration for ${WAN_INT}"
        fi
    done
    
    # Allow time for new delegations to be received
    sleep 5
    
    # Update ULA mappings with refreshed delegations
    trigger_ipv6_ula_mapping_update
}

# Enhanced router advertisement management
manage_ipv6_router_advertisements() {
    if [ "${ENABLE_IPV6_HA_MANAGEMENT}" != "yes" ] || [ "${ENABLE_IPV6_ROUTER_ADVERTISEMENTS}" != "yes" ]; then
        return 0
    fi
    
    logger -p info -t ${TAG} "Managing IPv6 router advertisements for CARP status: ${CARP_STATUS}"
    
    case "${CARP_STATUS}" in
        "MASTER")
            # Enable router advertisements on MASTER
            logger -p info -t ${TAG} "Enabling IPv6 router advertisements (MASTER)"
            
            # Trigger router advertisement daemon reconfiguration 
            # Note: radvd is managed by OPNsense's radvd_configure_do() function
            logger -p info -t ${TAG} "Triggering router advertisement daemon reconfiguration"
            if [ -x "/usr/local/etc/rc.configure_interface" ]; then
                # Trigger full interface reconfiguration which includes radvd restart
                /usr/local/etc/rc.configure_interface "${opnsense_interface}" >/dev/null 2>&1 || \
                    logger -p warning -t ${TAG} "Failed to reconfigure interface for radvd restart"
            fi
            
            # Ensure IPv6 forwarding is enabled for MASTER
            sysctl net.inet6.ip6.forwarding=1 >/dev/null 2>&1 || true
            ;;
        "BACKUP")
            # Stop router advertisements on BACKUP to prevent conflicts
            logger -p info -t ${TAG} "Stopping IPv6 router advertisements (BACKUP)"
            
            # Stop router advertisement daemon for BACKUP role
            # Note: radvd is stopped by killing the process directly
            if [ -f "/var/run/radvd.pid" ]; then
                logger -p info -t ${TAG} "Stopping router advertisement daemon"
                kill -TERM $(cat /var/run/radvd.pid) 2>/dev/null || true
            fi
            
            # Disable IPv6 forwarding on BACKUP
            sysctl net.inet6.ip6.forwarding=0 >/dev/null 2>&1 || true
            ;;
    esac
}

# Enhanced DHCPv6 server management for HA
manage_ipv6_dhcp_server() {
    if [ "${ENABLE_IPV6_HA_MANAGEMENT}" != "yes" ] || [ "${ENABLE_IPV6_DHCP_SERVER}" != "yes" ]; then
        return 0
    fi
    
    logger -p info -t ${TAG} "Managing IPv6 DHCPv6 server for CARP status: ${CARP_STATUS}"
    
    case "${CARP_STATUS}" in
        "MASTER")
            # Start DHCPv6 server on MASTER with updated delegations
            logger -p info -t ${TAG} "Starting IPv6 DHCPv6 server (MASTER)"
            
            # Start DHCPv6 server using correct OPNsense service management
            if command -v configctl >/dev/null 2>&1; then
                # Update DHCPv6 server configuration with current delegations
                configctl dhcpd6 restart >/dev/null 2>&1 || \
                    logger -p warning -t ${TAG} "Failed to restart DHCPv6 server"
            fi
            ;;
        "BACKUP")
            # Stop DHCPv6 server on BACKUP to prevent conflicts
            logger -p info -t ${TAG} "Stopping IPv6 DHCPv6 server (BACKUP)"
            
            # Stop DHCPv6 server using correct OPNsense service management
            if command -v configctl >/dev/null 2>&1; then
                configctl dhcpd6 stop >/dev/null 2>&1 || true
            fi
            ;;
    esac
}

# IPv6 interface configuration management
configure_ipv6_interfaces() {
    if [ "${ENABLE_IPV6_HA_MANAGEMENT}" != "yes" ]; then
        return 0
    fi
    
    logger -p info -t ${TAG} "Configuring IPv6 interfaces for MASTER role"
    
    # Configure each WAN interface for IPv6
    for WAN_INT in ${WAN_INTS}; do
        local opnsense_interface=$(get_opnsense_interface_name "${WAN_INT}")
        
        logger -p info -t ${TAG} "Configuring IPv6 on ${WAN_INT} (${opnsense_interface})"
        
        # Trigger IPv6 interface reconfiguration
        configctl interface newipv6 "${opnsense_interface}" >/dev/null 2>&1 || \
            logger -p warning -t ${TAG} "Failed to trigger IPv6 reconfiguration for ${WAN_INT}"
        
        # Ensure complete interface configuration including DHCPv6 client
        /usr/local/etc/rc.configure_interface "${opnsense_interface}" >/dev/null 2>&1 || \
            logger -p warning -t ${TAG} "Failed to fully configure interface ${WAN_INT}"
    done
    
    # Allow time for address assignment and delegation
    sleep 3
    
    # Verify IPv6 connectivity and log status
    verify_ipv6_connectivity
}

# IPv6 interface deconfiguration for BACKUP
deconfigure_ipv6_interfaces() {
    if [ "${ENABLE_IPV6_HA_MANAGEMENT}" != "yes" ]; then
        return 0
    fi
    
    logger -p info -t ${TAG} "Deconfiguring IPv6 interfaces for BACKUP role"
    
    # Note: We preserve DHCPv6 delegation state but remove active addresses
    # This allows faster failover when transitioning back to MASTER
    
    for WAN_INT in ${WAN_INTS}; do
        local opnsense_interface=$(get_opnsense_interface_name "${WAN_INT}")
        
        logger -p info -t ${TAG} "Deconfiguring IPv6 on ${WAN_INT} (${opnsense_interface})"
        
        # Remove IPv6 addresses but keep interface up for monitoring
        ifconfig "${WAN_INT}" inet6 -autoconf >/dev/null 2>&1 || true
        
        # Note: DHCPv6 client is managed by interface configuration, not direct service control
        # Gracefully remove IPv6 configuration while preserving delegation state
        logger -p info -t ${TAG} "IPv6 gracefully deconfigured for ${WAN_INT} (delegation state preserved)"
    done
}

# IPv6 connectivity verification
verify_ipv6_connectivity() {
    if [ "${ENABLE_IPV6_HA_MANAGEMENT}" != "yes" ]; then
        return 0
    fi
    
    logger -p info -t ${TAG} "Verifying IPv6 connectivity"
    
    # Check for IPv6 default route
    if netstat -rn -f inet6 | grep -q "^default"; then
        logger -p info -t ${TAG} "IPv6 default route present"
        
        # Test basic IPv6 connectivity if test address is configured
        if [ -n "${IPV6_TEST_ADDRESS:-}" ]; then
            if ping6 -c 1 -W 3000 "${IPV6_TEST_ADDRESS}" >/dev/null 2>&1; then
                logger -p info -t ${TAG} "IPv6 connectivity test successful"
            else
                logger -p warning -t ${TAG} "IPv6 connectivity test failed"
            fi
        fi
    else
        logger -p warning -t ${TAG} "No IPv6 default route found"
    fi
}

# Advanced IPv6 connectivity monitoring (Phase 3 Step 5)
start_ipv6_monitoring() {
    if [ "${ENABLE_IPV6_CONNECTIVITY_MONITORING}" != "yes" ]; then
        return 0
    fi
    
    logger -p info -t ${TAG} "Starting IPv6 connectivity monitoring"
    
    if [ -x "/usr/local/bin/ipv6-monitor" ]; then
        # Start monitoring daemon for continuous connectivity tracking
        /usr/local/bin/ipv6-monitor start >/dev/null 2>&1 || \
            logger -p warning -t ${TAG} "Failed to start IPv6 monitoring daemon"
    else
        logger -p warning -t ${TAG} "IPv6 monitoring script not found"
    fi
}

stop_ipv6_monitoring() {
    if [ "${ENABLE_IPV6_CONNECTIVITY_MONITORING}" != "yes" ]; then
        return 0
    fi
    
    logger -p info -t ${TAG} "Stopping IPv6 connectivity monitoring"
    
    if [ -x "/usr/local/bin/ipv6-monitor" ]; then
        /usr/local/bin/ipv6-monitor stop >/dev/null 2>&1 || true
    fi
}

check_ipv6_connectivity_status() {
    if [ "${ENABLE_IPV6_CONNECTIVITY_MONITORING}" != "yes" ]; then
        return 0
    fi
    
    if [ -x "/usr/local/bin/ipv6-monitor" ]; then
        # Get detailed connectivity status
        local status_output=$(/usr/local/bin/ipv6-monitor status 2>/dev/null)
        local exit_code=$?
        
        if [ ${exit_code} -eq 0 ]; then
            logger -p info -t ${TAG} "IPv6 connectivity monitoring: HEALTHY"
            return 0
        else
            logger -p warning -t ${TAG} "IPv6 connectivity monitoring: DEGRADED"
            return 1
        fi
    else
        logger -p warning -t ${TAG} "IPv6 monitoring not available"
        return 1
    fi
}

# IPv6 monitoring integration for CARP transitions
manage_ipv6_monitoring() {
    if [ "${ENABLE_IPV6_CONNECTIVITY_MONITORING}" != "yes" ]; then
        return 0
    fi
    
    logger -p info -t ${TAG} "Managing IPv6 monitoring for CARP status: ${CARP_STATUS}"
    
    case "${CARP_STATUS}" in
        "MASTER")
            # Start comprehensive monitoring on MASTER
            start_ipv6_monitoring
            
            # Perform immediate connectivity check
            if check_ipv6_connectivity_status; then
                logger -p info -t ${TAG} "IPv6 connectivity verified for MASTER role"
            else
                logger -p warning -t ${TAG} "IPv6 connectivity issues detected on MASTER"
            fi
            ;;
        "BACKUP")
            # Continue monitoring on BACKUP but with reduced frequency
            # This helps with failover decision making
            if [ -x "/usr/local/bin/ipv6-monitor" ]; then
                if /usr/local/bin/ipv6-monitor is-running | grep -q "running"; then
                    logger -p info -t ${TAG} "IPv6 monitoring continues on BACKUP for failover readiness"
                else
                    # Start monitoring even on BACKUP for failover decision support
                    start_ipv6_monitoring
                fi
            fi
            ;;
    esac
}

# IPv6 health assessment for failover decisions
assess_ipv6_health() {
    if [ "${ENABLE_IPV6_CONNECTIVITY_MONITORING}" != "yes" ]; then
        return 0  # Assume healthy if monitoring disabled
    fi
    
    if [ -x "/usr/local/bin/ipv6-monitor" ]; then
        # Run immediate connectivity check
        /usr/local/bin/ipv6-monitor check >/dev/null 2>&1
        local check_result=$?
        
        # Get current status
        local status_result=0
        /usr/local/bin/ipv6-monitor status >/dev/null 2>&1 || status_result=$?
        
        if [ ${check_result} -eq 0 ] && [ ${status_result} -eq 0 ]; then
            debug_log "IPv6 health assessment: HEALTHY"
            return 0
        else
            debug_log "IPv6 health assessment: DEGRADED"
            return 1
        fi
    else
        debug_log "IPv6 health assessment: MONITORING_UNAVAILABLE"
        return 0  # Don't fail if monitoring not available
    fi
}

# Interface management functions
get_interface_status() {
    local interface=$1
    if ifconfig -l -u | grep -q "${interface}"; then
        echo "UP"
    else
        echo "DOWN"
    fi
}

# Map device name to OPNsense interface name for configctl commands
get_opnsense_interface_name() {
    local device_name=$1
    
    # Parse WAN_INTERFACE_MAP format: "opnsense_name:device_name"
    echo "${WAN_INTERFACE_MAP}" | tr ' ' '\n' | while read mapping; do
        if [ -n "${mapping}" ]; then
            local opnsense_name=$(echo "${mapping}" | cut -d':' -f1)
            local device=$(echo "${mapping}" | cut -d':' -f2)
            if [ "${device}" = "${device_name}" ]; then
                echo "${opnsense_name}"
                return
            fi
        fi
    done
    
    # Default fallback: assume 'wan' if no mapping found
    echo "wan"
}

# DHCP lease clearing function - addresses cable modem stale lease issues
clear_dhcp_leases() {
    if [ "${ENABLE_DHCP_LEASE_CLEARING}" != "yes" ]; then
        debug_log "DHCP lease clearing disabled, skipping"
        return
    fi
    
    logger -p info -t ${TAG} "Clearing stale DHCP leases for clean failover"
    
    # Clear DHCP client lease files to force fresh DHCP negotiation
    # This addresses issues with cable modems (like Comcast) that maintain
    # stale lease state and reject renewals from virtual firewalls
    local dhcp_lease_files="/var/db/dhclient.leases*"
    
    for lease_file in ${dhcp_lease_files}; do
        if [ -f "${lease_file}" ]; then
            logger -p info -t ${TAG} "Removing DHCP lease file: ${lease_file}"
            rm -f "${lease_file}" 2>/dev/null || \
                logger -p warning -t ${TAG} "Failed to remove lease file: ${lease_file}"
        fi
    done
    
    # Also clear any interface-specific lease files
    for WAN_INT in ${WAN_INTS}; do
        local lease_file="/var/db/dhclient.leases.${WAN_INT}"
        if [ -f "${lease_file}" ]; then
            logger -p info -t ${TAG} "Removing interface-specific lease file: ${lease_file}"
            rm -f "${lease_file}" 2>/dev/null || \
                logger -p warning -t ${TAG} "Failed to remove lease file: ${lease_file}"
        fi
    done
    
    # Clear OPNsense DHCP client state files if they exist
    local opnsense_dhcp_state="/var/dhcpd/var/db"
    if [ -d "${opnsense_dhcp_state}" ]; then
        find "${opnsense_dhcp_state}" -name "dhclient*.lease*" -type f -exec rm -f {} \; 2>/dev/null || true
    fi
    
    logger -p info -t ${TAG} "DHCP lease clearing completed"
}

manage_wan_interfaces() {
    logger -p info -t ${TAG} "Managing WAN interfaces for CARP status: ${CARP_STATUS}"
    
    for WAN_INT in ${WAN_INTS}; do
        # Validate interface exists
        if ! ifconfig "${WAN_INT}" >/dev/null 2>&1; then
            logger -p warning -t ${TAG} "Interface ${WAN_INT} does not exist, skipping"
            continue
        fi
        
        local cur_status=$(get_interface_status "${WAN_INT}")
        debug_log "Interface ${WAN_INT} current status: ${cur_status}"
        
        case "${CARP_STATUS}" in
            "MASTER")
                if [ "${cur_status}" = "DOWN" ]; then
                    logger -p info -t ${TAG} "Bringing up ${WAN_INT} (CARP MASTER)"
                    # Use configctl with correct syntax (spaces not dots)
                    if configctl interface linkup start "${WAN_INT}" >/dev/null 2>&1; then
                        # Verify the interface came up
                        sleep 1
                        if [ "$(get_interface_status "${WAN_INT}")" = "DOWN" ]; then
                            logger -p warning -t ${TAG} "configctl failed to bring up ${WAN_INT}, using ifconfig fallback"
                            ifconfig "${WAN_INT}" up
                        fi
                    else
                        logger -p info -t ${TAG} "configctl failed, using ifconfig fallback for ${WAN_INT}"
                        ifconfig "${WAN_INT}" up
                    fi
                    
                    # Critical: Clear stale DHCP leases BEFORE interface reconfiguration
                    # This addresses cable modem lease binding issues with virtual firewalls
                    clear_dhcp_leases
                    
                    # Critical: Trigger OPNsense interface reconfiguration for DHCP renewal and routing
                    if [ "${ENABLE_INTERFACE_RECONFIGURE}" = "yes" ]; then
                        local opnsense_interface=$(get_opnsense_interface_name "${WAN_INT}")
                        logger -p info -t ${TAG} "Triggering interface reconfiguration for ${WAN_INT} (${opnsense_interface})"
                        
                        # IPv4 reconfiguration
                        if ! /usr/local/etc/rc.configure_interface "${opnsense_interface}" >/dev/null 2>&1; then
                            logger -p warning -t ${TAG} "interface reconfigure failed, triggering newip event"
                            # Fallback: trigger newip event to restore DHCP lease and routes
                            /usr/local/etc/rc.newwanip "${opnsense_interface}" force >/dev/null 2>&1 || \
                                logger -p warning -t ${TAG} "Failed to trigger newip event for ${WAN_INT}"
                        fi
                        
                        # IPv6 reconfiguration (Phase 2 Step 4 enhancement)
                        if [ "${ENABLE_IPV6_HA_MANAGEMENT}" = "yes" ] && [ "${ENABLE_IPV6_INTERFACE_RECONFIGURE}" = "yes" ]; then
                            logger -p info -t ${TAG} "Triggering IPv6 reconfiguration for ${WAN_INT} (${opnsense_interface})"
                            
                            # Trigger IPv6 address assignment and prefix delegation
                            configctl interface newipv6 "${opnsense_interface}" >/dev/null 2>&1 || \
                                logger -p warning -t ${TAG} "Failed to trigger IPv6 reconfiguration for ${WAN_INT}"
                            
                            # Restart DHCPv6 client for fresh delegation via interface reconfiguration
                            /usr/local/etc/rc.configure_interface "${opnsense_interface}" >/dev/null 2>&1 || \
                                logger -p warning -t ${TAG} "Failed to reconfigure interface for DHCPv6 restart on ${WAN_INT}"
                        fi
                    else
                        debug_log "Interface reconfiguration disabled, skipping DHCP renewal"
                    fi
                else
                    # Interface already UP - trigger lease renewal for clean MASTER state
                    if [ "${ENABLE_INTERFACE_RECONFIGURE}" = "yes" ]; then
                        local opnsense_interface=$(get_opnsense_interface_name "${WAN_INT}")
                        
                        # Clear stale leases before renewal for clean MASTER state
                        clear_dhcp_leases
                        
                        # Trigger IPv4 lease renewal to establish fresh DHCP state
                        configctl interface newip "${opnsense_interface}" >/dev/null 2>&1 || \
                            logger -p warning -t ${TAG} "Failed to trigger DHCP renewal for ${WAN_INT}"
                        
                        # IPv6 renewal and delegation refresh (Phase 2 Step 4 enhancement)
                        if [ "${ENABLE_IPV6_HA_MANAGEMENT}" = "yes" ] && [ "${ENABLE_IPV6_INTERFACE_RECONFIGURE}" = "yes" ]; then
                            logger -p info -t ${TAG} "Refreshing IPv6 configuration for ${WAN_INT} (${opnsense_interface})"
                            
                            # Refresh IPv6 configuration and delegations
                            configctl interface newipv6 "${opnsense_interface}" >/dev/null 2>&1 || \
                                logger -p warning -t ${TAG} "Failed to refresh IPv6 configuration for ${WAN_INT}"
                            
                            # Refresh DHCPv6 delegations via interface reconfiguration
                            /usr/local/etc/rc.configure_interface "${opnsense_interface}" >/dev/null 2>&1 || \
                                logger -p warning -t ${TAG} "Failed to reconfigure interface for DHCPv6 refresh on ${WAN_INT}"
                        fi
                    else
                        debug_log "${WAN_INT} already UP, no action needed"
                    fi
                fi
                ;;
            "BACKUP")
                if [ "${cur_status}" = "UP" ]; then
                    logger -p info -t ${TAG} "Bringing down ${WAN_INT} (CARP BACKUP)"
                    # Use configctl with correct syntax (spaces not dots)
                    if configctl interface linkup stop "${WAN_INT}" >/dev/null 2>&1; then
                        # Verify the interface went down
                        sleep 1
                        if [ "$(get_interface_status "${WAN_INT}")" = "UP" ]; then
                            logger -p warning -t ${TAG} "configctl failed to bring down ${WAN_INT}, using ifconfig fallback"
                            ifconfig "${WAN_INT}" down
                        fi
                    else
                        logger -p info -t ${TAG} "configctl failed, using ifconfig fallback for ${WAN_INT}"
                        ifconfig "${WAN_INT}" down
                    fi
                else
                    debug_log "${WAN_INT} already DOWN, no action needed"
                fi
                ;;
        esac
    done
}

# Service management functions
check_service_status() {
    local service=$1
    service "${service}" status >/dev/null 2>&1
    return $?
}

start_service() {
    local service=$1
    logger -p info -t ${TAG} "Starting service: ${service}"
    
    # Skip configctl for IPv6 services that don't have configctl actions
    case "${service}" in
        rtsold|dhcp6c|radvd)
            # Use direct daemon commands for IPv6 services
            case "${service}" in
                rtsold)
                    # Use conditional rtsold scripts based on CARP state
                    if [ "${CARP_STATUS}" = "MASTER" ]; then
                        # Full rtsold with scripts for proper IPv6 operation
                        /usr/sbin/rtsold -aiu -p /var/run/rtsold.pid -A /var/etc/rtsold_script.sh -R /usr/local/opnsense/scripts/interfaces/rtsold_resolvconf.sh
                    else
                        # Minimal rtsold for BACKUP state to avoid interface conflicts
                        /usr/sbin/rtsold -aiu -p /var/run/rtsold.pid
                    fi
                    ;;
                radvd)
                    /usr/local/sbin/radvd -p /var/run/radvd.pid -C /var/etc/radvd.conf -m syslog
                    ;;
                dhcp6c)
                    # Enhanced dhcp6c startup with interface validation
                    local dhcp6c_config="/var/etc/dhcp6c.conf"
                    if [ -f "${dhcp6c_config}" ]; then
                        # Kill any existing dhcp6c processes that might be stuck
                        pkill -f dhcp6c 2>/dev/null || true
                        sleep 1
                        # Start dhcp6c with fresh configuration
                        /usr/local/sbin/dhcp6c -c "${dhcp6c_config}" -p /var/run/dhcp6c.pid
                        debug_log "Started dhcp6c with config: ${dhcp6c_config}"
                    else
                        logger -p warning -t ${TAG} "dhcp6c config file not found: ${dhcp6c_config}"
                    fi
                    ;;
            esac
            ;;
        *)
            # Try configctl for other services
            if ! configctl "${service}" start 2>/dev/null; then
                logger -p warning -t ${TAG} "Unknown service for configctl: ${service}"
                return 1
            fi
            ;;
    esac
}

stop_service() {
    local service=$1
    logger -p info -t ${TAG} "Stopping service: ${service}"
    
    # Skip configctl for IPv6 services that don't have configctl actions  
    case "${service}" in
        rtsold|dhcp6c|radvd)
            # Use FreeBSD service management for IPv6 services
            service "${service}" onestop
            ;;
        *)
            # Try configctl for other services
            if ! configctl "${service}" stop 2>/dev/null; then
                service "${service}" onestop
            fi
            ;;
    esac
}

restart_service() {
    local service=$1
    logger -p info -t ${TAG} "Restarting service: ${service}"
    
    # For IPv6 services, we need to restart them to rebind to correct interfaces
    case "${service}" in
        rtsold|dhcp6c|radvd)
            # Stop the service first
            service "${service}" onestop 2>/dev/null || true
            # Wait a moment for cleanup
            sleep 1
            # Start with fresh interface bindings
            start_service "${service}"
            ;;
        *)
            # Try configctl restart or fall back to service restart
            if ! configctl "${service}" restart 2>/dev/null; then
                service "${service}" onerestart 2>/dev/null || service "${service}" restart
            fi
            ;;
    esac
}

manage_services() {
    if [ "${ENABLE_SERVICE_MANAGEMENT}" != "yes" ]; then
        debug_log "Service management disabled, skipping"
        return
    fi
    
    logger -p info -t ${TAG} "Managing services for CARP status: ${CARP_STATUS}"
    
    for service in ${SERVICES}; do
        if check_service_status "${service}"; then
            local service_running=true
        else
            local service_running=false
        fi
        
        debug_log "Service ${service} running: ${service_running}"
        
        case "${CARP_STATUS}" in
            "MASTER")
                if [ "${service_running}" = "false" ]; then
                    start_service "${service}"
                else
                    # Critical fix: Restart IPv6 services when becoming MASTER
                    # This ensures they rebind to the correct interfaces
                    case "${service}" in
                        rtsold|dhcp6c|radvd)
                            logger -p info -t ${TAG} "Restarting ${service} for interface rebinding"
                            restart_service "${service}"
                            ;;
                        *)
                            debug_log "Service ${service} already running"
                            ;;
                    esac
                fi
                ;;
            "BACKUP")
                if [ "${service_running}" = "true" ]; then
                    stop_service "${service}"
                else
                    debug_log "Service ${service} already stopped"
                fi
                ;;
        esac
    done
}

# Route management functions
verify_default_route() {
    local expected_gateway=$1
    local family=$2
    local max_retries=${3:-${ROUTE_RETRY_COUNT}}
    local retry_delay=${4:-${ROUTE_RETRY_DELAY}}
    
    logger -p info -t ${TAG} "Verifying ${family} default route to ${expected_gateway}"
    
    local attempt=1
    while [ ${attempt} -le ${max_retries} ]; do
        if check_route_exists "${expected_gateway}" "${family}"; then
            logger -p info -t ${TAG} "Verified ${family} default route to ${expected_gateway} (attempt ${attempt})"
            return 0
        fi
        
        logger -p warning -t ${TAG} "Default route verification failed (attempt ${attempt}/${max_retries})"
        
        if [ ${attempt} -lt ${max_retries} ]; then
            # Try to add the route manually
            logger -p info -t ${TAG} "Attempting to add ${family} default route via ${expected_gateway}"
            case "${family}" in
                "ipv4")
                    route add default "${expected_gateway}" 2>/dev/null || \
                        logger -p warning -t ${TAG} "Failed to manually add IPv4 route"
                    ;;
                "ipv6")
                    route -6 add default "${expected_gateway}" 2>/dev/null || \
                        logger -p warning -t ${TAG} "Failed to manually add IPv6 route"
                    ;;
            esac
            
            logger -p info -t ${TAG} "Waiting ${retry_delay} seconds before retry"
            sleep ${retry_delay}
        fi
        
        attempt=$((attempt + 1))
    done
    
    logger -p error -t ${TAG} "Failed to verify ${family} default route after ${max_retries} attempts"
    return 1
}

force_arp_resolution() {
    local gateway=$1
    local interface=$2
    
    logger -p info -t ${TAG} "Forcing ARP resolution for gateway ${gateway} via ${interface}"
    
    # Send ping to force ARP resolution
    ping -c 1 -W 2000 -S "${interface}" "${gateway}" >/dev/null 2>&1 || \
        logger -p warning -t ${TAG} "ARP resolution ping failed for ${gateway}"
    
    # Check if ARP entry exists
    if arp -n "${gateway}" >/dev/null 2>&1; then
        logger -p info -t ${TAG} "ARP entry confirmed for ${gateway}"
        return 0
    else
        logger -p warning -t ${TAG} "No ARP entry found for ${gateway}"
        return 1
    fi
}

get_interface_gateway() {
    local interface=$1
    local family=$2
    
    case "${family}" in
        "ipv4")
            # Get IPv4 gateway from routing table for this interface
            netstat -rn -f inet | awk -v iface="${interface}" '$6 == iface && /^default/ {print $2}' | head -1
            ;;
        "ipv6")
            # Get IPv6 gateway from routing table for this interface
            netstat -rn -f inet6 | awk -v iface="${interface}" '$4 == iface && /^default/ {print $2}' | head -1
            ;;
    esac
}

verify_and_fix_master_routes() {
    if [ "${ENABLE_ROUTE_VERIFICATION}" != "yes" ]; then
        debug_log "Route verification disabled, skipping"
        return
    fi
    
    logger -p info -t ${TAG} "Verifying and fixing MASTER routes after interface reconfiguration"
    
    # Wait for interface configuration to settle
    sleep ${ROUTE_RETRY_DELAY}
    
    # Check each WAN interface for proper routing
    for WAN_INT in ${WAN_INTS}; do
        if [ "$(get_interface_status "${WAN_INT}")" = "UP" ]; then
            logger -p info -t ${TAG} "Checking routes for interface ${WAN_INT}"
            
            # Get the expected gateway for this interface
            local ipv4_gw=$(get_interface_gateway "${WAN_INT}" "ipv4")
            
            if [ -n "${ipv4_gw}" ]; then
                logger -p info -t ${TAG} "Expected IPv4 gateway for ${WAN_INT}: ${ipv4_gw}"
                
                # Force ARP resolution first
                force_arp_resolution "${ipv4_gw}" "${WAN_INT}"
                
                # Verify the route exists and is working
                if ! verify_default_route "${ipv4_gw}" "ipv4"; then
                    logger -p warning -t ${TAG} "IPv4 route verification failed for ${WAN_INT}, triggering interface reset"
                    
                    # Try to reset the interface completely
                    local opnsense_interface=$(get_opnsense_interface_name "${WAN_INT}")
                    logger -p info -t ${TAG} "Triggering emergency interface reset for ${WAN_INT} (${opnsense_interface})"
                    
                    # Force interface down/up cycle
                    ifconfig "${WAN_INT}" down
                    sleep 1
                    ifconfig "${WAN_INT}" up
                    sleep 2
                    
                    # Trigger configctl reconfiguration again
                    /usr/local/etc/rc.configure_interface "${opnsense_interface}" >/dev/null 2>&1 || \
                        /usr/local/etc/rc.newwanip "${opnsense_interface}" force >/dev/null 2>&1
                    
                    # Wait and verify again
                    sleep ${ROUTE_RETRY_DELAY}
                    
                    # Get updated gateway info
                    ipv4_gw=$(get_interface_gateway "${WAN_INT}" "ipv4")
                    if [ -n "${ipv4_gw}" ]; then
                        force_arp_resolution "${ipv4_gw}" "${WAN_INT}"
                        verify_default_route "${ipv4_gw}" "ipv4" 1 1 || \
                            logger -p error -t ${TAG} "Emergency route fix failed for ${WAN_INT}"
                    fi
                fi
            else
                logger -p warning -t ${TAG} "No IPv4 gateway found for ${WAN_INT}"
            fi
            
            # Handle IPv6 if enabled
            if [ "${ENABLE_IPV6}" = "yes" ]; then
                local ipv6_gw=$(get_interface_gateway "${WAN_INT}" "ipv6")
                if [ -n "${ipv6_gw}" ]; then
                    logger -p info -t ${TAG} "Verifying IPv6 gateway for ${WAN_INT}: ${ipv6_gw}"
                    verify_default_route "${ipv6_gw}" "ipv6" 2 1 || \
                        logger -p warning -t ${TAG} "IPv6 route verification failed for ${WAN_INT}"
                fi
            fi
        fi
    done
}

check_route_exists() {
    local gateway=$1
    local family=$2
    
    case "${family}" in
        "ipv4")
            # Check if default route exists via this gateway
            netstat -rn -f inet | grep "^default" | grep -q "${gateway}"
            return $?
            ;;
        "ipv6")
            # Check if default IPv6 route exists via this gateway
            netstat -rn -f inet6 | grep "^default" | grep -q "${gateway}"
            return $?
            ;;
    esac
    return 1
}

get_default_routes() {
    local family=$1
    case "${family}" in
        "ipv4")
            netstat -rn -f inet | awk '/^default/ {print $2}'
            ;;
        "ipv6")
            netstat -rn -f inet6 | awk '/^default/ {print $2}'
            ;;
        *)
            return 1
            ;;
    esac
}

check_route_exists() {
    local route_ip=$1
    local family=$2
    
    case "${family}" in
        "ipv4")
            netstat -rn -f inet | grep -q "default.*${route_ip}"
            ;;
        "ipv6")
            netstat -rn -f inet6 | grep -q "default.*${route_ip}"
            ;;
        *)
            return 1
            ;;
    esac
}

remove_default_routes() {
    local family=$1
    
    logger -p info -t ${TAG} "Removing existing ${family} default routes"
    
    case "${family}" in
        "ipv4")
            get_default_routes "ipv4" | while read route_gw; do
                if [ -n "${route_gw}" ]; then
                    logger -p info -t ${TAG} "Removing IPv4 default route via ${route_gw}"
                    route delete default "${route_gw}" 2>/dev/null || true
                fi
            done
            ;;
        "ipv6")
            get_default_routes "ipv6" | while read route_gw; do
                if [ -n "${route_gw}" ]; then
                    logger -p info -t ${TAG} "Removing IPv6 default route via ${route_gw}"
                    route -6 delete default "${route_gw}" 2>/dev/null || true
                fi
            done
            ;;
    esac
}

manage_routes() {
    if [ "${ENABLE_ROUTE_MANAGEMENT}" != "yes" ]; then
        debug_log "Route management disabled, skipping"
        return
    fi
    
    logger -p info -t ${TAG} "Managing backup routes for CARP status: ${CARP_STATUS}"
    
    # Check current route status
    if check_route_exists "${ALT_DEFROUTE_IPV4}" "ipv4"; then
        local ipv4_alt_route_exists=true
    else
        local ipv4_alt_route_exists=false
    fi
    
    if [ "${ENABLE_IPV6}" = "yes" ] && check_route_exists "${ALT_DEFROUTE_IPV6}" "ipv6"; then
        local ipv6_alt_route_exists=true
    else
        local ipv6_alt_route_exists=false
    fi
    
    debug_log "IPv4 alt route exists: ${ipv4_alt_route_exists}, IPv6 alt route exists: ${ipv6_alt_route_exists}"
    
    case "${CARP_STATUS}" in
        "MASTER")
            # Remove any backup routes when becoming master (normal routing will be restored)
            logger -p info -t ${TAG} "Removing backup routes (becoming MASTER)"
            
            if check_route_exists "${ALT_DEFROUTE_IPV4}" "ipv4"; then
                logger -p info -t ${TAG} "Removing IPv4 backup route via ${ALT_DEFROUTE_IPV4}"
                route delete default "${ALT_DEFROUTE_IPV4}" 2>/dev/null || true
            fi
            
            if [ "${ENABLE_IPV6}" = "yes" ] && check_route_exists "${ALT_DEFROUTE_IPV6}" "ipv6"; then
                logger -p info -t ${TAG} "Removing IPv6 backup route via ${ALT_DEFROUTE_IPV6}"
                route -6 delete default "${ALT_DEFROUTE_IPV6}" 2>/dev/null || true
            fi
            
            # Verify that proper MASTER routes are established after interface reconfiguration
            verify_and_fix_master_routes
            ;;
        "BACKUP")
            # For BACKUP state, remove existing default routes and add backup routes
            logger -p info -t ${TAG} "Configuring backup routing (removing current defaults, adding backup routes)"
            
            # Remove existing default routes first
            remove_default_routes "ipv4"
            if [ "${ENABLE_IPV6}" = "yes" ]; then
                remove_default_routes "ipv6"
            fi
            
            # Wait a moment for route table to settle
            sleep 1
            
            # Add backup routes
            logger -p info -t ${TAG} "Adding IPv4 backup default route via ${ALT_DEFROUTE_IPV4}"
            route add default "${ALT_DEFROUTE_IPV4}" 2>/dev/null || \
                logger -p warning -t ${TAG} "Failed to add IPv4 backup route"
            
            if [ "${ENABLE_IPV6}" = "yes" ]; then
                logger -p info -t ${TAG} "Adding IPv6 backup default route via ${ALT_DEFROUTE_IPV6}"
                route -6 add default "${ALT_DEFROUTE_IPV6}" 2>/dev/null || \
                    logger -p warning -t ${TAG} "Failed to add IPv6 backup route"
            fi
            ;;
    esac
}

# IPv6 integration functions
trigger_ipv6_updates() {
    if [ "${ENABLE_IPV6}" != "yes" ]; then
        return
    fi
    
    # Trigger IPv6 prefix delegation updates if scripts exist
    if [ -x "/usr/local/bin/dhcp6c-ula-mapping.py" ]; then
        debug_log "Triggering IPv6 prefix updates"
        /usr/local/bin/dhcp6c-ula-mapping.py 2>/dev/null || true
    fi
    
    # Update CARP service status for IPv6
    if [ -x "/usr/local/sbin/carp_service_status" ]; then
        /usr/local/sbin/carp_service_status 2>/dev/null || true
    fi
}

# Health check function
perform_health_checks() {
    local exit_code=0
    
    # Check if critical interfaces exist
    for WAN_INT in ${WAN_INTS}; do
        if ! ifconfig "${WAN_INT}" >/dev/null 2>&1; then
            logger -p error -t ${TAG} "Critical interface ${WAN_INT} missing"
            exit_code=1
        fi
    done
    
    # Check if we're in a reasonable state
    if [ "${CARP_STATUS}" = "MASTER" ]; then
        for WAN_INT in ${WAN_INTS}; do
            if [ "$(get_interface_status "${WAN_INT}")" = "DOWN" ]; then
                logger -p warning -t ${TAG} "Master node has interface ${WAN_INT} down"
            fi
        done
        
        # IPv6 health assessment for MASTER (Phase 3 Step 5)
        if [ "${ENABLE_IPV6_HA_MANAGEMENT}" = "yes" ]; then
            if ! assess_ipv6_health; then
                logger -p warning -t ${TAG} "IPv6 connectivity health check failed on MASTER"
                # Note: Don't fail completely, just log the warning
            fi
        fi
    fi
    
    return ${exit_code}
}

# Main execution
main() {
    logger -p info -t ${TAG} "Starting HA failover processing"
    
    # Perform health checks
    if ! perform_health_checks; then
        logger -p error -t ${TAG} "Health checks failed, continuing with limited functionality"
    fi
    
    # Execute management functions in correct order
    manage_wan_interfaces
    
    # Wait for interface changes to settle before managing services
    if [ "${CARP_STATUS}" = "MASTER" ]; then
        debug_log "Waiting ${INTERFACE_SETTLE_TIME} seconds for interface changes to settle"
        sleep "${INTERFACE_SETTLE_TIME}"
    fi
    
    manage_services
    manage_routes
    
    # Process IPv6 HA management (NEW in v2.8)
    process_ipv6_carp_transition
    
    trigger_ipv6_updates
    
    # Update CARP service status (OPNsense HA health monitoring integration)
    if command -v /usr/local/sbin/carp_service_status >/dev/null 2>&1; then
        logger -p debug -t ${TAG} "Updating CARP service status"
        /usr/local/sbin/carp_service_status 2>/dev/null || true
    fi
    
    logger -p info -t ${TAG} "HA failover processing completed successfully"
}

# Execute main function
main

